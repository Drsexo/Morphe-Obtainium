name: Build
on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

jobs:
  check:
    name: Check for updates
    permissions: write-all
    runs-on: ubuntu-latest
    outputs:
      SHOULD_BUILD: ${{ steps.check_updates.outputs.SHOULD_BUILD }}
      BUILD_MORPHE: ${{ steps.check_updates.outputs.BUILD_MORPHE }}
      BUILD_REVANCED: ${{ steps.check_updates.outputs.BUILD_REVANCED }}
      BUILD_PIKO: ${{ steps.check_updates.outputs.BUILD_PIKO }}
      LAST_BUILD_DATE: ${{ steps.check_updates.outputs.LAST_BUILD_DATE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for patch updates
        id: check_updates
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_MANUAL: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          LAST_BUILD_DATE=$(gh release list -L 20 --json createdAt -q '[.[].createdAt] | sort | last' 2>/dev/null | cut -d'T' -f1 || echo "")

          if [ -z "$LAST_BUILD_DATE" ] || ! date -d "$LAST_BUILD_DATE" &>/dev/null 2>&1; then
            LAST_BUILD_DATE=$(date -u -d "30 days ago" +%Y-%m-%d)
          fi
          echo "LAST_BUILD_DATE=$LAST_BUILD_DATE" >> $GITHUB_OUTPUT

          if [ "$IS_MANUAL" = "true" ]; then
            echo "Manual trigger - building all apps"
            echo "SHOULD_BUILD=1" >> $GITHUB_OUTPUT
            echo "BUILD_MORPHE=true" >> $GITHUB_OUTPUT
            echo "BUILD_REVANCED=true" >> $GITHUB_OUTPUT
            echo "BUILD_PIKO=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          BUILD_MORPHE="false"
          BUILD_REVANCED="false"
          BUILD_PIKO="false"

          MORPHE_RELEASES=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/MorpheApp/morphe-patches/releases" | \
            jq -r --arg since "$LAST_BUILD_DATE" \
            '[.[] | select(.prerelease == false and .published_at > $since)] | length')
          if [ "$MORPHE_RELEASES" -gt 0 ]; then
            echo "Found $MORPHE_RELEASES new Morphe patches release(s)"
            BUILD_MORPHE="true"
          fi

          REVANCED_RELEASES=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/ReVanced/revanced-patches/releases" | \
            jq -r --arg since "$LAST_BUILD_DATE" \
            '[.[] | select(.prerelease == false and .published_at > $since)] | length')
          if [ "$REVANCED_RELEASES" -gt 0 ]; then
            echo "Found $REVANCED_RELEASES new ReVanced patches release(s)"
            BUILD_REVANCED="true"
          fi

          PIKO_RELEASES=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/crimera/piko/releases" | \
            jq -r --arg since "$LAST_BUILD_DATE" \
            '[.[] | select(.prerelease == false and .published_at > $since)] | length')
          if [ "$PIKO_RELEASES" -gt 0 ]; then
            echo "Found $PIKO_RELEASES new Piko patches release(s)"
            BUILD_PIKO="true"
          fi

          if [ "$BUILD_MORPHE" = "true" ] || [ "$BUILD_REVANCED" = "true" ] || [ "$BUILD_PIKO" = "true" ]; then
            echo "SHOULD_BUILD=1" >> $GITHUB_OUTPUT
          else
            echo "SHOULD_BUILD=0" >> $GITHUB_OUTPUT
          fi

          echo "BUILD_MORPHE=$BUILD_MORPHE" >> $GITHUB_OUTPUT
          echo "BUILD_REVANCED=$BUILD_REVANCED" >> $GITHUB_OUTPUT
          echo "BUILD_PIKO=$BUILD_PIKO" >> $GITHUB_OUTPUT

      - name: Clear old workflow runs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run list -L400 --json databaseId -q '.[].databaseId' | tail -n+10 | xargs -IID gh api "repos/${{ github.repository }}/actions/runs/ID" -X DELETE || :

  build:
    name: Build apps
    needs: check
    if: ${{ needs.check.outputs.SHOULD_BUILD == '1' }}
    permissions: write-all
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "21"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true

      - name: Get date and version code
        id: date_ver
        run: |
          echo "DATE=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT
          echo "NEXT_VER_CODE=$(date -u +%Y%m%d)" >> $GITHUB_OUTPUT

      - name: Build modules/APKs
        run: |
          chmod +x build.sh
          find bin -type f -exec chmod +x {} \;
          ./build.sh config.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          NEXT_VER_CODE: ${{ steps.date_ver.outputs.NEXT_VER_CODE }}
          LAST_BUILD_DATE: ${{ needs.check.outputs.LAST_BUILD_DATE }}
          BUILD_MORPHE: ${{ needs.check.outputs.BUILD_MORPHE }}
          BUILD_REVANCED: ${{ needs.check.outputs.BUILD_REVANCED }}
          BUILD_PIKO: ${{ needs.check.outputs.BUILD_PIKO }}

      - name: Check if build produced any files
        id: check_build
        run: |
          if [ -z "$(ls -A build/ 2>/dev/null)" ]; then
            echo "No build artifacts found"
            echo "HAS_ARTIFACTS=false" >> $GITHUB_OUTPUT
          else
            echo "Build artifacts found:"
            ls -la build/
            echo "HAS_ARTIFACTS=true" >> $GITHUB_OUTPUT
          fi

      - name: Create per-app releases
        if: steps.check_build.outputs.HAS_ARTIFACTS == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -f temp/release_tags.log ]; then
            echo "No release tags found"
            exit 0
          fi

          sort -u -t'|' -k1,1 temp/release_tags.log > temp/release_tags_unique.log

          while IFS='|' read -r release_tag release_tag_base release_title files_prefix; do
            [ -z "$release_tag" ] && continue

            echo "Processing: ${release_tag} (${release_title})"

            matching_files=()
            for f in build/${files_prefix}-v*.apk build/${files_prefix}-v*.zip build/${files_prefix}-magisk-v*.zip; do
              [ -f "$f" ] && matching_files+=("$f")
            done

            if [ ${#matching_files[@]} -eq 0 ]; then
              echo "No files for ${files_prefix}, skipping"
              continue
            fi

            notes_file="temp/release_notes/${release_tag_base}.md"
            if [ -f "$notes_file" ]; then
              release_body=$(cat "$notes_file")
            else
              release_body="## ${release_title}"
            fi

            # Delete old release with same base tag pattern (previous version)
            old_tags=$(gh release list --json tagName -q '.[].tagName' | grep "^${release_tag_base}-v" || true)
            for old_tag in $old_tags; do
              if [ "$old_tag" != "$release_tag" ]; then
                echo "  Deleting old release: ${old_tag}"
                gh release delete "$old_tag" --yes --cleanup-tag 2>/dev/null || true
              fi
            done

            if gh release view "$release_tag" &>/dev/null; then
              echo "  Updating existing release"
              gh release view "$release_tag" --json assets -q '.assets[].name' | while read -r asset_name; do
                gh release delete-asset "$release_tag" "$asset_name" --yes 2>/dev/null || true
              done
              gh release edit "$release_tag" \
                --title "${release_title}" \
                --notes "${release_body}"
            else
              echo "  Creating new release"
              gh release create "$release_tag" \
                --title "${release_title}" \
                --notes "${release_body}"
            fi

            for f in "${matching_files[@]}"; do
              echo "  Uploading: $(basename "$f")"
              gh release upload "$release_tag" "$f" --clobber
            done

          done < temp/release_tags_unique.log

      - name: Update Magisk update JSONs
        if: steps.check_build.outputs.HAS_ARTIFACTS == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if ! git checkout -f update 2>/dev/null; then
            git switch --discard-changes --orphan update
          fi

          generate_update_json() {
            echo "{
              \"version\": \"$1\",
              \"versionCode\": ${{ steps.date_ver.outputs.NEXT_VER_CODE }},
              \"zipUrl\": \"$2\",
              \"changelog\": \"https://raw.githubusercontent.com/${{ github.repository }}/update/build.md\"
            }"
          }

          if [ -d build ]; then
            cd build
            for OUTPUT in *magisk*.zip; do
              [ "$OUTPUT" = "*magisk*.zip" ] && continue
              ZIP_S=$(unzip -p "$OUTPUT" module.prop 2>/dev/null) || continue
              UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson || continue)
              UPDATE_JSON="${UPDATE_JSON##*/}"
              VER=$(echo "$ZIP_S" | grep version=)
              VER="${VER##*=}"

              # Find matching release tag from release_tags.log
              module_base="${OUTPUT%-magisk-v*}"
              module_ver="${OUTPUT#*-magisk-}"
              module_ver="${module_ver%-arm64-v8a.zip}"
              module_ver="${module_ver%-arm-v7a.zip}"
              DLURL="${{ github.server_url }}/${{ github.repository }}/releases/download/${module_base}-${module_ver}/${OUTPUT}"
              generate_update_json "$VER" "$DLURL" > "../$UPDATE_JSON"
            done
            cd ..
          fi

          find . -name "*-update.json" | grep . || echo "{}" > dummy-update.json

      - uses: stefanzweifel/git-auto-commit-action@v5
        if: steps.check_build.outputs.HAS_ARTIFACTS == 'true'
        with:
          branch: update
          skip_checkout: true
          file_pattern: build.md *-update.json
          commit_message: "Build ${{ steps.date_ver.outputs.DATE }}"